<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MATH337: Changepoint Detection - 3&nbsp; Multiple changepoints</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./4_algos_and_penalties.html" rel="next">
<link href="./2_control.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./3_multiple_changes.html"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Multiple changepoints</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">MATH337: Changepoint Detection</a> 
        <div class="sidebar-tools-main">
    <a href="./MATH337--Changepoint-Detection.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1_intro_cusum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">An Introduction to Changepoint Detection</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2_control.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Controlling the CUSUM and Other Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3_multiple_changes.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Multiple changepoints</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./4_algos_and_penalties.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">PELT, WBS and Penalty choices</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./5_real_data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Working with Real Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#introduction" id="toc-introduction" class="nav-link active" data-scroll-target="#introduction"><span class="header-section-number">3.1</span> Introduction</a>
  <ul class="collapse">
  <li><a href="#real-example-genomic-data-and-neuroblastoma" id="toc-real-example-genomic-data-and-neuroblastoma" class="nav-link" data-scroll-target="#real-example-genomic-data-and-neuroblastoma"><span class="header-section-number">3.1.1</span> Real Example: Genomic Data and Neuroblastoma</a></li>
  <li><a href="#towards-multiple-changes" id="toc-towards-multiple-changes" class="nav-link" data-scroll-target="#towards-multiple-changes"><span class="header-section-number">3.1.2</span> Towards multiple changes</a></li>
  <li><a href="#the-cost-of-a-segmentation" id="toc-the-cost-of-a-segmentation" class="nav-link" data-scroll-target="#the-cost-of-a-segmentation"><span class="header-section-number">3.1.3</span> The cost of a segmentation</a></li>
  <li><a href="#the-best-segmentation" id="toc-the-best-segmentation" class="nav-link" data-scroll-target="#the-best-segmentation"><span class="header-section-number">3.1.4</span> The “best” segmentation</a></li>
  </ul></li>
  <li><a href="#binary-segmentation" id="toc-binary-segmentation" class="nav-link" data-scroll-target="#binary-segmentation"><span class="header-section-number">3.2</span> Binary Segmentation</a>
  <ul class="collapse">
  <li><a href="#binary-segmentation-in-action" id="toc-binary-segmentation-in-action" class="nav-link" data-scroll-target="#binary-segmentation-in-action"><span class="header-section-number">3.2.1</span> Binary Segmentation in action</a></li>
  </ul></li>
  <li><a href="#optimal-partitioning" id="toc-optimal-partitioning" class="nav-link" data-scroll-target="#optimal-partitioning"><span class="header-section-number">3.3</span> Optimal Partitioning</a>
  <ul class="collapse">
  <li><a href="#optimal-partitinioning-in-action" id="toc-optimal-partitinioning-in-action" class="nav-link" data-scroll-target="#optimal-partitinioning-in-action"><span class="header-section-number">3.3.1</span> Optimal partitinioning in action</a></li>
  <li><a href="#neuroblastoma-example" id="toc-neuroblastoma-example" class="nav-link" data-scroll-target="#neuroblastoma-example"><span class="header-section-number">3.3.2</span> Neuroblastoma example</a></li>
  </ul></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">3.4</span> Exercises</a>
  <ul class="collapse">
  <li><a href="#workshop-3" id="toc-workshop-3" class="nav-link" data-scroll-target="#workshop-3"><span class="header-section-number">3.4.1</span> Workshop 3</a></li>
  <li><a href="#lab-3" id="toc-lab-3" class="nav-link" data-scroll-target="#lab-3"><span class="header-section-number">3.4.2</span> Lab 3</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Multiple changepoints</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="introduction" class="level2" data-number="3.1">
<h2 data-number="3.1" class="anchored" data-anchor-id="introduction"><span class="header-section-number">3.1</span> Introduction</h2>
<p>In real-world data, it is common to encounter situations where more than one change occurs. When applying the CUSUM statistic in such cases, where there are <strong>multiple changes</strong>, the question arises: how does CUSUM behave, and how can we detect these multiple changes effectively?</p>
<section id="real-example-genomic-data-and-neuroblastoma" class="level3" data-number="3.1.1">
<h3 data-number="3.1.1" class="anchored" data-anchor-id="real-example-genomic-data-and-neuroblastoma"><span class="header-section-number">3.1.1</span> Real Example: Genomic Data and Neuroblastoma</h3>
<p>To motivate this discussion, we return to the example from week 1: detecting active genomic regions using <em>ChIP-seq data</em>. Our goal here is to identify copy number variations (CNVs)—structural changes in the genome where DNA sections are duplicated or deleted. These variations can impact gene expression and are linked to diseases like cancer, including neuroblastoma. The dataset we’ll examine consists of logratios of genomic probe intensities, which help us detect changes in the underlying DNA structure.</p>
<p>Statistically our objective is to segment this logratio sequence into regions with different means, corresponding to different genomic states:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>As seen from the plot, the data is noisy, but there are visible shifts in the logratio values, suggesting multiple changes in the underlying copy number. By the end of this chapter, we will segment this sequence!</p>
</section>
<section id="towards-multiple-changes" class="level3" data-number="3.1.2">
<h3 data-number="3.1.2" class="anchored" data-anchor-id="towards-multiple-changes"><span class="header-section-number">3.1.2</span> Towards multiple changes</h3>
<p>Under this framework, the observed sequence <span class="math inline">\(y_t\)</span> can be modeled as a piecewise constant signal with changes in the mean occurring at each changepoint <span class="math inline">\(\tau_k\)</span>. A plausible model for the change-in-mean signal is given by</p>
<p><span class="math display">\[
y_t = \mu_k + \epsilon_t, \quad \text{for} \ \tau_k \leq t &lt; \tau_{k+1}, \ k = 0, 1, \dots, K,
\]</span></p>
<p>where <span class="math inline">\(\mu_k\)</span> is the mean of the <span class="math inline">\(k\)</span>-th segment, and <span class="math inline">\(\epsilon_t \sim \mathcal{N}(0, \sigma^2)\)</span> are independent Gaussian noise terms with mean 0 and (known) variance <span class="math inline">\(\sigma^2\)</span>.</p>
<p>As a starting example, we can generate a sequence with 4 segments, with <span class="math inline">\(\tau_1 = 50, \tau_2 = 100, \tau_3 = 150\)</span> and means <span class="math inline">\(\mu_1 = 2, \mu_2 = 0, \mu_3 = -1\)</span> and <span class="math inline">\(\mu_4 = 2\)</span>. Running the CUSUM statistic in this scenario with multiple changes, leads to the following <span class="math inline">\(C_\tau^2\)</span> trace:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>From this, we notice that our test still has power to detect some of the changes, but the estimate that we get, is initially wrong. <span class="math inline">\(\Delta \mu = |\mu_1 - \mu_2|\)</span>. Is power lost when there is more then one change in our test?</p>
<p>Well, to answer this question, we can compare the values of the CUSUM statistic ran on the whole dataset (as above), with the values of the CUSUM, ran on a subset containing only one change:</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Warning: Removed 199 rows containing missing values or values outside the scale range
(`geom_line()`).</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can see that max of the old cusum (the line in grey) is much lower than the one where we isolate the sequence on one single change! So there is an effective loss of power in this scenario in analyzing all changes together, as some changes are masking the effects of others…</p>
<p>This gives us motivation to move towards some methodology that tries to estimate all changes locations jointly, rather then one at a time!</p>
</section>
<section id="the-cost-of-a-segmentation" class="level3" data-number="3.1.3">
<h3 data-number="3.1.3" class="anchored" data-anchor-id="the-cost-of-a-segmentation"><span class="header-section-number">3.1.3</span> The cost of a segmentation</h3>
<p>Well, so far we only worked with one scheme that tried to split a sequence in a hald</p>
<p>But how can we work in case we have more than one change? Well, we need to introduce the cost of a segment.</p>
<p>If we assume the data is independent and identically distributed within each segment, for segment parameter <span class="math inline">\(\theta\)</span>, then this cost can be obtained through:</p>
<p><span class="math display">\[
    \mathcal{L}(y_{s+1:t}) = \min_\theta \sum_{i = s + 1}^{t} - \log(f(y_i, \theta))
\]</span></p>
<p>with <span class="math inline">\(f(y, \theta)\)</span> being the likelihood for data point <span class="math inline">\(y\)</span> if the segment parameter is <span class="math inline">\(\theta\)</span>. Now, for example, in the gaussian case this cost is given by:</p>
<p><span class="math display">\[
\mathcal{L}(y_{s:t}) = \frac{1}{2\sigma^2}  \sum_{i = s}^{t} \left ( y_i - \bar{y}_{s:t} \right)^2
\]</span></p>
<p>The cost for the full segmentation will be given by the sum across all segments:</p>
<p><span class="math display">\[
\sum_{k = 0}^K \mathcal{L}(y_{\tau_k+1:\tau_{k+1}})
\]</span></p>
<p>Interestingly, the cost of a full segmentation is closely related to the LR test. Consider, a single Gaussian change-in-mean at time <span class="math inline">\(\tau\)</span>, splitting the data into two segments: <span class="math inline">\(y_{1:\tau}\)</span> and <span class="math inline">\(y_{\tau+1:n}\)</span>. The cost of this segmentation is:</p>
<p><span class="math display">\[
\mathcal{L}(y_{1:\tau}) + \mathcal{L}(y_{\tau+1:n}) = \frac{1}{\sigma^2} \left[\sum_{i=1}^{\tau} (y_i - \bar{y}_{1:\tau})^2 + \sum_{i=\tau+1}^{n} (y_i - \bar{y}_{(\tau+1):n})^2 \right]
\]</span></p>
<p>Which is essentially the same LR test as we saw last week, without the null component. Specifically, for one change, minimizing the segmentation cost over all possible changepoints locations <span class="math inline">\(\tau\)</span> is equivalent to maximizing the CUSUM statistic.</p>
</section>
<section id="the-best-segmentation" class="level3" data-number="3.1.4">
<h3 data-number="3.1.4" class="anchored" data-anchor-id="the-best-segmentation"><span class="header-section-number">3.1.4</span> The “best” segmentation</h3>
<p>We now have a way of evaluating how “good” a segmentation is, so it’s only natural to ask the question: what would be the best one?</p>
<p>Well, one way would be to, say, finding the the best set of <span class="math inline">\(\tau = \tau_0, \dots, \tau_{K+1}\)</span> changepoints that minimise the cost:</p>
<p><span id="eq-segment_cost"><span class="math display">\[
\min_{\substack{K \in \mathbb{N}\\ \tau_1, \dots, \tau_K}} \sum_{k = 0}^K \mathcal{L}(y_{\tau_k+1:\tau_{k+1}}).
\tag{3.1}\]</span></span></p>
<p>Which one would this be? Say that for instance we range the <span class="math inline">\(K = 1, \dots, n\)</span>, and at each step we find the best possible segmentation. Graphically, we would be observing the following:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-5-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-5-3.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-5-4.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Well, arguably we would like to stop at 4, which we know is the real number of segments, but the cost keep going down…</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-6-2.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>And finally:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="source_imgs/fine.png" class="img-fluid quarto-figure quarto-figure-center figure-img" width="486"></p>
</figure>
</div>
<p>Well, it turns out, that according to the minimization above, the optimal segmentation across all would be the one that puts each point into its own segment!</p>
<p>Well, there are different solutions to this problem. The first one we will see, is a divide-and-conquer greedy approach, called Binary Segmentation, and the second one will aim a generating a different optimization to the one below that will find the optimal segmentation <em>up to a constant</em> to avoid over-fitting!</p>
</section>
</section>
<section id="binary-segmentation" class="level2" data-number="3.2">
<h2 data-number="3.2" class="anchored" data-anchor-id="binary-segmentation"><span class="header-section-number">3.2</span> Binary Segmentation</h2>
<p>Binary Segmentation (BS) is a procedure from and . Binary segmentation works like this:</p>
<ol type="1">
<li>Start with a test for a change <span class="math inline">\(\tau\)</span> that splits a sequence into two segments and to check if the cost over those two segments, plus a penalty <span class="math inline">\(\beta \in \mathbb{R}\)</span>, is smaller then the cost computed on the whole sequence: <span id="eq-bin_seg_condition"><span class="math display">\[
    \mathcal{L}(y_{1:\tau}) + \mathcal{L}(y_{\tau+1:n}) + \beta &lt; \mathcal{L}(y_{1:n})     
\tag{3.2}\]</span></span></li>
</ol>
<p>where the segment cost <span class="math inline">\(\mathcal{L}(\cdot)\)</span>, is as in <a href="#eq-segment_cost" class="quarto-xref">Equation&nbsp;<span class="quarto-unresolved-ref">eq-segment_cost</span></a>.</p>
<ol start="2" type="1">
<li><p>If the condition in <a href="#eq-bin_seg_condition" class="quarto-xref">Equation&nbsp;<span class="quarto-unresolved-ref">eq-bin_seg_condition</span></a> is true for at least one <span class="math inline">\(\tau \in 1, \dots, n\)</span>, then the <span class="math inline">\(\tau\)</span> that minimizes <span class="math inline">\(\mathcal{L}(y_{1:\tau}) + \mathcal{L}(y_{\tau+1:n})\)</span> is picked as a first changepoint and the test is then performed on the two newly generated splits. This step is repeated until no further changepoints are detected on all resulting segments.</p></li>
<li><p>If there are no more resulting valid splits, then the procedure ends.</p></li>
</ol>
<p>Some of you might have noted how the condition in <a href="#eq-bin_seg_condition" class="quarto-xref">Equation&nbsp;<span class="quarto-unresolved-ref">eq-bin_seg_condition</span></a> is closely related to the LR test in <a href="#eq-lr-test" class="quarto-xref">Equation&nbsp;<span class="quarto-unresolved-ref">eq-lr-test</span></a>. In fact, rearranging equation above, gives us:</p>
<p><span class="math display">\[
- \mathcal{L}(y_{1:n}) + \mathcal{L}(y_{1:\tau}) + \mathcal{L}(y_{\tau+1:n}) = - \frac{LR_\tau}{2}  &lt; -\beta.
\]</span></p>
<p>The <span class="math inline">\(-\beta\)</span> acts exactly as the constant <span class="math inline">\(c\)</span> for declaring a change, and it adds a natural stopping condition, solving the issue of overfitting that we mentioned in the previous section! Binary Segmentation, in fact, does nothing more then iteratively running a LR test, until no changes are found anymore!</p>
<p>This gives us a strategy to essentially apply a test that is locally optimal for one change, such as the Likelihood Ratio test, to solve a multiple changepoint segmentation. For this reason, BS is often employed to extend single changepoint procedures to multiple changes procedures, and hence it is one of the most prominent methods in the literature.</p>
<section id="binary-segmentation-in-action" class="level3" data-number="3.2.1">
<h3 data-number="3.2.1" class="anchored" data-anchor-id="binary-segmentation-in-action"><span class="header-section-number">3.2.1</span> Binary Segmentation in action</h3>
<p>Having introduced the main idea, we show now how binary segmentation works in action with an example above. Say that we set a <span class="math inline">\(\beta = 2 \log(400) =\)</span> 11.98.</p>
<p><strong>Step 1:</strong> We start by computing the cost as in <a href="#eq-bin_seg_condition" class="quarto-xref">Equation&nbsp;<span class="quarto-unresolved-ref">eq-bin_seg_condition</span></a>, and for those that are less then <span class="math inline">\(\beta\)</span>, we pick the smallest. This will be our first changepoint estimate, and the first point of split.</p>
<p>In the plots below, the blue horizontal line is the mean signal estimated for a given split, while in the cusum the pink will represent the values of the LR below the threshold <span class="math inline">\(\beta\)</span>, and red vertical line will show the min of the test statistics. When the cost is below the beta line, this will be our changepoint estimate.</p>
<p>In our case, we can see that the min of our cost has been achieved for <span class="math inline">\(\hat\tau=100\)</span>, and since this is below the threshold, it’s our first estimated changepoint!</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>Step 2:</strong></p>
<p>From the first step, we have to check now two splits:</p>
<ul>
<li><p>The first left split, <strong>1-LEFT</strong> in the plot below, covers data <span class="math inline">\(y_{1:100}\)</span>. We can see that from here, the min of our statistic is below the threshold, therefore we won’t declare any further change in this subset.</p></li>
<li><p>The first right split, <strong>1-RIGHT</strong> covers data <span class="math inline">\(y_{101:400}\)</span>. We can see that here, the min of the statistics, is below the threshold, and therefore we identify a second change at <span class="math inline">\(\hat\tau = 297\)</span>. This is not exactly 300, so we don’t have a perfect estimate. Despite this is not ideal, this is the best point we have found and therefore we have to continue!</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>Step 3:</strong></p>
<p>In step 3, we have to check again two splits splits:</p>
<ul>
<li><p>The second left split, <strong>2-LEFT</strong> in the plot below, covers data <span class="math inline">\(y_{101:297}\)</span>. Now, it’s in this split that the statistics goes below the threshold! The third estimated change is at <span class="math inline">\(\hat\tau = 203\)</span>, again slightly off the real one at 200. We continue investigating this split…</p></li>
<li><p>The second right split, <strong>2-RIGHT</strong> covers data <span class="math inline">\(y_{298:400}\)</span>. In this last split, the min is not over the threshold, therefore we stop the search.</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>Step 4:</strong></p>
<p>In step 4, we check:</p>
<ul>
<li><p>The third left split, <strong>3-LEFT</strong> in the plot below, covers data <span class="math inline">\(y_{101:203}\)</span>. The minimum, in here is not over the threshold.</p></li>
<li><p>The third right split, <strong>3-RIGHT</strong> covers data <span class="math inline">\(y_{204:298}\)</span>. Similarly, the minimum is not over the treshold.</p></li>
</ul>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-11-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The algorithm therefore terminates!</p>
<p>With this graphical description in mind, we formally describe the Binary Segmentation algorithm as a recursive procedure, where the first iteration would be simply given by <span class="math inline">\(\text{BinSeg}(y_{1:n}, \beta)\)</span>.</p>
<hr>
<div class="line-block"><span class="math inline">\(\text{BinSeg}(y_{s:t}, \beta)\)</span><br>
</div>
<hr>
<div class="line-block"><strong>INPUT:</strong> Subseries <span class="math inline">\(y_{s:t} = \{y_s, \dots, y_t\}\)</span> of length <span class="math inline">\(t - s + 1\)</span>, penalty <span class="math inline">\(\beta\)</span><br>
<strong>OUTPUT:</strong> Set of detected changepoints <span class="math inline">\(cp\)</span><br>
<br>
<strong>IF</strong> <span class="math inline">\(t - s \leq 1\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<strong>RETURN</strong> <span class="math inline">\(\{\}\)</span> // No changepoint in segments of length 1 or less<br>
<br>
<strong>COMPUTE</strong><br>
<span class="math inline">\(\mathcal{Q} \leftarrow \underset{\tau \in \{s, \dots, t\}}{\min} \left[ \mathcal{L}(y_{s:\tau}) + \mathcal{L}(y_{\tau+1:t}) - \mathcal{L}(y_{s:t}) + \beta \right]\)</span><br>
<br>
<strong>IF</strong> <span class="math inline">\(\mathcal{Q} &lt; 0\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(\hat{\tau} \leftarrow \underset{\tau \in \{s, \dots, t\}}{\text{arg}\min} \left[ \mathcal{L}(y_{s:\tau}) + \mathcal{L}(y_{\tau+1:t}) - \mathcal{L}(y_{s:t}) \right]\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(cp \leftarrow \{ \hat{\tau}, \text{BinSeg}(y_{s:\hat{\tau}}, \beta), \text{BinSeg}(y_{\hat{\tau}+1:t}, \beta) + \hat\tau \}\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>RETURN</strong> <span class="math inline">\(cp\)</span><br>
<br>
<strong>RETURN</strong> <span class="math inline">\(\{\}\)</span> // No changepoint if <span class="math inline">\(-LR/2\)</span> is above penalty <span class="math inline">\(- \beta\)</span></div>
<hr>
</section>
</section>
<section id="optimal-partitioning" class="level2" data-number="3.3">
<h2 data-number="3.3" class="anchored" data-anchor-id="optimal-partitioning"><span class="header-section-number">3.3</span> Optimal Partitioning</h2>
<p>Another solution to avoid the over-fitting problem of <a href="#eq-segment_cost" class="quarto-xref">Equation&nbsp;<span class="quarto-unresolved-ref">eq-segment_cost</span></a> lies in introducing a penalty term that discourages too many changepoints, avoiding overfitting. This is known as the <em>penalised approach</em>.</p>
<p>To achieve this, we want to minimize the following cost function:</p>
<p><span id="eq-pen-cost"><span class="math display">\[
Q_{n, \beta} = \min_{K \in \mathbb{N}} \left[ \min_{\substack{\\ \tau_1, \dots, \tau_K}} \sum_{k = 0}^K \mathcal{L}(y_{\tau_k+1:\tau_{k+1}}) + \beta K
\right],
\tag{3.3}\]</span></span></p>
<p>where <span class="math inline">\(Q_{n, \beta}\)</span> represents the optimal cost for segmenting the data up to time <span class="math inline">\(n\)</span> with a penalty $ $ that increases with each additional changepoint <span class="math inline">\(K\)</span>. With the <span class="math inline">\(\beta\)</span> term, for every new changepoint added, the cost of the full segmentation increases, discouraging therefore models with too many changepoints.</p>
<p>Unlike Binary Segmentation, which works iteratively and makes local decisions about potential changepoints, and as we have seen it is prone to errors, solving <span class="math inline">\(Q_{n, \beta}\)</span> ensures that the segmentation is <strong>globally optimal</strong>, as in the location of the changes are the best possible to minimise our cost.</p>
<p>Now, directly solving this problem using a brute-force search is computationally prohibitive, as it would require checking every possible combination of changepoints across the sequence: the number of possible segmentations grows exponentially as <span class="math inline">\(n\)</span> increases…</p>
<p>Fortunately, this problem can be solved efficiently using a sequential, dynamic programming algorithm: <strong>Optimal Partitioning (OP)</strong>, from <span class="citation" data-cites="Jackson">Jackson et al. (<a href="#ref-Jackson" role="doc-biblioref">2005</a>)</span>. OP solves <a href="#eq-pen-cost" class="quarto-xref">Equation&nbsp;<span class="quarto-unresolved-ref">eq-pen-cost</span></a> exactly through the following recursion.</p>
<p>We start with <span class="math inline">\(\mathcal{Q}_{0, \beta} = -\beta\)</span>, and then, for each <span class="math inline">\(t = 1, \dots, n\)</span>, we compute:</p>
<p><span id="eq-optimal-partitioning"><span class="math display">\[
    \mathcal{Q}_{t, \beta} = \min_{0 \leq \tau &lt; t} \left[ \mathcal{Q}_{\tau, \beta} + \mathcal{L}(y_{\tau + 1:t}) + \beta \right].
\tag{3.4}\]</span></span></p>
<p>Here, <span class="math inline">\(\mathcal{Q}_{t, \beta}\)</span> represents the optimal cost of segmenting the data up to time <span class="math inline">\(t\)</span>. The algorithm builds this solution sequentially by considering each possible segmentation <span class="math inline">\(\mathcal{Q}_{0, \beta},\ \cdots, \mathcal{Q}_{t-2, \beta},\ \mathcal{Q}_{t-1, \beta}\)</span> before the current time <span class="math inline">\(t\)</span>, plus the segment cost up to current time <span class="math inline">\(t\)</span>, <span class="math inline">\(\mathcal{L}(y_{\tau + 1:t})\)</span>.</p>
<section id="optimal-partitinioning-in-action" class="level3" data-number="3.3.1">
<h3 data-number="3.3.1" class="anchored" data-anchor-id="optimal-partitinioning-in-action"><span class="header-section-number">3.3.1</span> Optimal partitinioning in action</h3>
<p>This recursion can be quite hard to digest, and is, as usual, best described graphically.</p>
<p><strong>Step 1</strong> Say we are at <span class="math inline">\(t = 1\)</span>. In this case, according to equation above, the optimal cost up to time one will be given by (remember that the <span class="math inline">\(\beta\)</span> cancels out with <span class="math inline">\(Q_{0, \beta}\)</span>!):</p>
<p><span class="math display">\[
\mathcal{Q}_{1, \beta} = \left[ -\beta + \mathcal{L}(y_{1:1}) + \beta \right] = \mathcal{L}(y_{1:1})
\]</span></p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><strong>Step 2.</strong> Now, at the second step, we have to minimise between two segmentations:</p>
<ul>
<li>One with the whole sequence in a second segment alone (again, <span class="math inline">\(\beta\)</span> cancels out with <span class="math inline">\(Q_{0, \beta} = -\beta\)</span>), and this will be given by <span class="math inline">\(\mathcal{L}(y_{1:2})\)</span> (dotted line)</li>
<li>One with the optimal segmentation from step 1 <span class="math inline">\(\mathcal{Q}_{1, \beta}\)</span> (whose cost considered only the first point in its own segment!), to which we have to sum the cost relative to a second segment <span class="math inline">\(\mathcal{L}(y_{2:2})\)</span> that puts the second point alone, and the penalty <span class="math inline">\(\beta\)</span> as we have added a new segment!</li>
</ul>
<p>We minimise across the two, and this gives us <span class="math inline">\(Q_{2, \beta}\)</span>.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-13-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><em>Step 3</em>: Similarly, at <span class="math inline">\(t = 3\)</span> we have now three segmentations to choose from:</p>
<ul>
<li><p>The one that puts the first three observations in the same segment, whose cost will be given simply by <span class="math inline">\(\mathcal{L}(y_{1:2})\)</span>,</p></li>
<li><p>The one considering the optimal segmentation from time 1, plus the cost of adding an extra segment with observation 2 and 3 together</p></li>
<li><p>Finally the optimal from segmentation 2, <span class="math inline">\(\mathcal{Q}_{2, \beta}\)</span>, plus the segment cost of fitting an extra segment with point 3 alone. Note that <span class="math inline">\(\mathcal{Q}_{2, \beta}\)</span> will come from the step before: if we would have been beneficial to add a change, at the previous step, this information is carried over!</p></li>
</ul>
<p>Again, we pick the minimum across these three to get <span class="math inline">\(\mathcal{Q}_{3, \beta}\)</span>, and proceed.</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-14-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p><em>Step</em> <span class="math inline">\(n\)</span> Until the last step! Which would look something like this:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-15-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>A formal description of the algorithm can be found below:</p>
<hr>
<div class="line-block"><strong>INPUT:</strong> Time series <span class="math inline">\(y = (y_1, ..., y_n)\)</span>, penalty <span class="math inline">\(\beta\)</span><br>
<strong>OUTPUT:</strong> Optimal changepoint vector <span class="math inline">\(cp_n\)</span><br>
<br>
Initialize <span class="math inline">\(\mathcal{Q}_0 \leftarrow -\beta\)</span><br>
Initialize <span class="math inline">\(cp_0 \leftarrow \{\}\)</span><br>
<br>
<strong>FOR</strong> <span class="math inline">\(t = 1, \dots, n\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(\mathcal{Q}_t \leftarrow \min_{0 \leq \tau &lt; t} \left[ \mathcal{Q}_{\tau} + \mathcal{L}(y_{\tau + 1:t}) + \beta \right]\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(\hat\tau \leftarrow \text{arg}\min_{0 \leq \tau &lt; t} \left[ \mathcal{Q}_{\tau} + \mathcal{L}(y_{\tau + 1:t}) + \beta \right]\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(cp_t \leftarrow (cp_{\hat\tau}, \hat\tau)\)</span> // Append the changepoint to the list at the last optimal point<br>
<br>
<strong>RETURN</strong> <span class="math inline">\(cp_n\)</span></div>
<hr>
<p>Running the Optimal Partitioning method on our example scenario, with the same penalty <span class="math inline">\(\beta = 2 \log(400) =\)</span> 11.98 as above, gives changepoint locations <span class="math inline">\(\tau_{1:4} = \{100, 203, 301\}\)</span>.</p>
<div class="cell">
<div class="cell-output cell-output-stderr">
<pre><code>Loading required package: zoo</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>
Attaching package: 'zoo'</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>The following objects are masked from 'package:base':

    as.Date, as.Date.numeric</code></pre>
</div>
<div class="cell-output cell-output-stderr">
<pre><code>Successfully loaded changepoint package version 2.2.4
 See NEWS for details of changes.</code></pre>
</div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-16-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>So we can see how on this dataset in particular, OP performs slightly better then Binary Segmentation on the last change, getting closer to the real changepoint of 300!</p>
</section>
<section id="neuroblastoma-example" class="level3" data-number="3.3.2">
<h3 data-number="3.3.2" class="anchored" data-anchor-id="neuroblastoma-example"><span class="header-section-number">3.3.2</span> Neuroblastoma example</h3>
<p>Returning to the original example at the start of the module, the neuroblastoma dataset, we run both Binary Segmentation, and Optimal Partitioning.</p>
<p>We report results in the plot below (blue for BS, green for OP). In this case, the algorithms return the same four changepoints:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="3_multiple_changes_files/figure-html/unnamed-chunk-17-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Some of you might come up with two (very interesting) questions that hopefully we will answer next week…</p>
<ul>
<li><p>If the methods perform roughly the same, which one do I choose?</p></li>
<li><p>Why is the data on a different scale then that presented at the start of the chapter?</p></li>
</ul>
</section>
</section>
<section id="exercises" class="level2" data-number="3.4">
<h2 data-number="3.4" class="anchored" data-anchor-id="exercises"><span class="header-section-number">3.4</span> Exercises</h2>
<section id="workshop-3" class="level3" data-number="3.4.1">
<h3 data-number="3.4.1" class="anchored" data-anchor-id="workshop-3"><span class="header-section-number">3.4.1</span> Workshop 3</h3>
<ol type="1">
<li>For the vector <span class="math inline">\(y_{1:4} = (0.5, -0.1, 12.1, 12.4)\)</span>, and a penalty <span class="math inline">\(\beta = 5\)</span> calculate, pen on paper (and calculator), all the Binary Segmentation, and Optimal Partitioning steps. <strong>TIP</strong>: To speed up computations, you want to pre-compute all segment costs <span class="math inline">\(\mathcal{L}(y_{l:u})\)</span>. I have pre-computed some of these costs in the table below:</li>
</ol>
<p><span class="math display">\[
\begin{array}{c|cccc}
l \backslash u &amp; 1 &amp; 2 &amp; 3 &amp; 4 \\
\hline
1 &amp; \mathcal{L}(y_{1:1}) &amp; 0.18 &amp; 94.59 &amp; 145.43 \\
2 &amp;  &amp; 0.00 &amp; \mathcal{L}(y_{2:3}) &amp; 101.73 \\
3 &amp;  &amp;  &amp; 0.00 &amp; \mathcal{L}(y_{3:4}) \\
4 &amp;  &amp;  &amp;  &amp; 0.00 \\
\end{array}
\]</span></p>
</section>
<section id="lab-3" class="level3" data-number="3.4.2">
<h3 data-number="3.4.2" class="anchored" data-anchor-id="lab-3"><span class="header-section-number">3.4.2</span> Lab 3</h3>
<ol type="1">
<li><p>Code the Optimal Partitioning algorithm for the Gaussian change-in-mean case.<br>
<strong>Tips:</strong></p>
<ol type="a">
<li><p>Again, you can pre-compute all the possible <span class="math inline">\(\mathcal{L}(y_{l:u})\)</span>, for <span class="math inline">\(u \geq l\)</span> to save computational time.</p></li>
<li><p>Be very careful with indexing… R starts indexing at 1, however, in the pseudocode, you have one element that starts at 0…</p></li>
</ol></li>
<li><p>Install the <code>changepoint</code> package. The example signal of Section 3.4, with the same penalty value of <span class="math inline">\(\beta = 2 * log(n)\)</span>, compare your implementation of OP, Binary Segmentation, and PELT. You will learn how to do so in the documentation, running <code>?cpt_mean</code>. You should make 300 replicates each of your experiment, and compare:</p>
<ol type="a">
<li><p>The absolute error loss from the mean signal, e.g.&nbsp;<span class="math inline">\(||\mu_{1:n} - \hat{\mu}_{1:n}||^2_2\)</span></p></li>
<li><p>The absolute error in the number of changepoints reconstructed, e.g.&nbsp;<span class="math inline">\(|K - \hat{K}|\)</span>. What do we observe?</p></li>
<li><p>The runtime for one sequence of PELT agains Binary Segmentation. Evaluate the runtime with package <code>microbenchmark</code>.</p></li>
</ol></li>
</ol>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-Jackson" class="csl-entry" role="listitem">
Jackson, Brad, Jeffrey Scargle, D. Barnes, S. Arabhi, A. Alt, P. Gioumousis, E. Gwin, P. Sangtrakulcharoen, L. Tan, and Tun Tsai. 2005. <span>“An Algorithm for Optimal Partitioning of Data on an Interval.”</span> <em>Signal Processing Letters, IEEE</em> 12 (March): 105–8. <a href="https://doi.org/10.1109/LSP.2001.838216">https://doi.org/10.1109/LSP.2001.838216</a>.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./2_control.html" class="pagination-link" aria-label="Controlling the CUSUM and Other Models">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Controlling the CUSUM and Other Models</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./4_algos_and_penalties.html" class="pagination-link" aria-label="PELT, WBS and Penalty choices">
        <span class="nav-page-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">PELT, WBS and Penalty choices</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>