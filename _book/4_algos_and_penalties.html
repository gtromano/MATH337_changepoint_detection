<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.4.550">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>MATH337: Changepoint Detection - 4&nbsp; PELT, WBS and Penalty choices</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
/* CSS for citations */
div.csl-bib-body { }
div.csl-entry {
  clear: both;
  margin-bottom: 0em;
}
.hanging-indent div.csl-entry {
  margin-left:2em;
  text-indent:-2em;
}
div.csl-left-margin {
  min-width:2em;
  float:left;
}
div.csl-right-inline {
  margin-left:2em;
  padding-left:1em;
}
div.csl-indent {
  margin-left: 2em;
}</style>


<script src="site_libs/quarto-nav/quarto-nav.js"></script>
<script src="site_libs/quarto-nav/headroom.min.js"></script>
<script src="site_libs/clipboard/clipboard.min.js"></script>
<script src="site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="site_libs/quarto-search/fuse.min.js"></script>
<script src="site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="./">
<link href="./5_real_data.html" rel="next">
<link href="./3_multiple_changes.html" rel="prev">
<script src="site_libs/quarto-html/quarto.js"></script>
<script src="site_libs/quarto-html/popper.min.js"></script>
<script src="site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="site_libs/quarto-html/anchor.min.js"></script>
<link href="site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="site_libs/bootstrap/bootstrap.min.js"></script>
<link href="site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="nav-sidebar floating">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <nav class="quarto-page-breadcrumbs" aria-label="breadcrumb"><ol class="breadcrumb"><li class="breadcrumb-item"><a href="./4_algos_and_penalties.html"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">PELT, WBS and Penalty choices</span></a></li></ol></nav>
        <a class="flex-grow-1" role="button" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="./">MATH337: Changepoint Detection</a> 
        <div class="sidebar-tools-main">
    <a href="./MATH337--Changepoint-Detection.pdf" title="Download PDF" class="quarto-navigation-tool px-1" aria-label="Download PDF"><i class="bi bi-file-pdf"></i></a>
</div>
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Preface</span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./1_intro_cusum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">1</span>&nbsp; <span class="chapter-title">An Introduction to Changepoint Detection</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./2_control.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">2</span>&nbsp; <span class="chapter-title">Controlling the CUSUM and Other Models</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./3_multiple_changes.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Multiple changepoints</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./4_algos_and_penalties.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">PELT, WBS and Penalty choices</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./5_real_data.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Working with Real Data</span></span></a>
  </div>
</li>
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="./references.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">References</span></a>
  </div>
</li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item"></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#drawbacks-of-op-and-bs" id="toc-drawbacks-of-op-and-bs" class="nav-link active" data-scroll-target="#drawbacks-of-op-and-bs"><span class="header-section-number">4.1</span> Drawbacks of OP and BS</a>
  <ul class="collapse">
  <li><a href="#quality-of-the-segmentation" id="toc-quality-of-the-segmentation" class="nav-link" data-scroll-target="#quality-of-the-segmentation"><span class="header-section-number">4.1.1</span> Quality of the Segmentation</a></li>
  <li><a href="#computational-complexity" id="toc-computational-complexity" class="nav-link" data-scroll-target="#computational-complexity"><span class="header-section-number">4.1.2</span> Computational Complexity</a></li>
  </ul></li>
  <li><a href="#pelt-and-wbs" id="toc-pelt-and-wbs" class="nav-link" data-scroll-target="#pelt-and-wbs"><span class="header-section-number">4.2</span> PELT and WBS</a>
  <ul class="collapse">
  <li><a href="#pelt-an-efficient-solution-to-op" id="toc-pelt-an-efficient-solution-to-op" class="nav-link" data-scroll-target="#pelt-an-efficient-solution-to-op"><span class="header-section-number">4.2.1</span> PELT: an efficient solution to OP</a></li>
  <li><a href="#wbs-improving-on-binary-segmentation" id="toc-wbs-improving-on-binary-segmentation" class="nav-link" data-scroll-target="#wbs-improving-on-binary-segmentation"><span class="header-section-number">4.2.2</span> WBS: Improving on Binary Segmentation</a></li>
  </ul></li>
  <li><a href="#penalty-selection" id="toc-penalty-selection" class="nav-link" data-scroll-target="#penalty-selection"><span class="header-section-number">4.3</span> Penalty Selection</a>
  <ul class="collapse">
  <li><a href="#example-in-r-comparing-penalties-with-pelt" id="toc-example-in-r-comparing-penalties-with-pelt" class="nav-link" data-scroll-target="#example-in-r-comparing-penalties-with-pelt"><span class="header-section-number">4.3.1</span> Example in R: Comparing Penalties with PELT</a></li>
  <li><a href="#crops-running-with-multiple-penalties" id="toc-crops-running-with-multiple-penalties" class="nav-link" data-scroll-target="#crops-running-with-multiple-penalties"><span class="header-section-number">4.3.2</span> CROPS: running with multiple penalties</a></li>
  </ul></li>
  <li><a href="#exercises" id="toc-exercises" class="nav-link" data-scroll-target="#exercises"><span class="header-section-number">4.4</span> Exercises</a>
  <ul class="collapse">
  <li><a href="#workshop-4" id="toc-workshop-4" class="nav-link" data-scroll-target="#workshop-4"><span class="header-section-number">4.4.1</span> Workshop 4</a></li>
  <li><a href="#lab-4" id="toc-lab-4" class="nav-link" data-scroll-target="#lab-4"><span class="header-section-number">4.4.2</span> Lab 4</a></li>
  </ul></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span class="chapter-number">4</span>&nbsp; <span class="chapter-title">PELT, WBS and Penalty choices</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="drawbacks-of-op-and-bs" class="level2" data-number="4.1">
<h2 data-number="4.1" class="anchored" data-anchor-id="drawbacks-of-op-and-bs"><span class="header-section-number">4.1</span> Drawbacks of OP and BS</h2>
<p>When deciding which segmentation approach to use, Binary Segmentation (BS) and Optimal Partitioning (OP) each offer different strengths. The choice largely depends on the characteristics of the data and the goal of the analysis.</p>
<section id="quality-of-the-segmentation" class="level3" data-number="4.1.1">
<h3 data-number="4.1.1" class="anchored" data-anchor-id="quality-of-the-segmentation"><span class="header-section-number">4.1.1</span> Quality of the Segmentation</h3>
<p>Generally, Optimal Partitioning (OP) provides the <em>most accurate segmentation</em>, especially when we have a well-defined model and expect precise changepoint detection. OP ensures that the solution is optimal by globally minimizing the cost function across all possible segmentations. This is ideal for datasets with clear changes, even if noise is present.</p>
<p>Let’s consider a case with true changepoints at <span class="math inline">\(\tau = 100, 200, 300\)</span>, and segment means <span class="math inline">\(\mu_{1:4} = 2, 1, -1, 1.5\)</span>:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-2-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>While the underlying signal follows these clear shifts, noise complicates segmentation. Binary Segmentation uses a greedy process where each iteration looks for the largest changepoint. Although fast, this local search can make mistakes if the signal isn’t perfectly clear, particularly in the early stages of the algorithm. For example, running BS on this dataset introduces a mistake at <span class="math inline">\(\tau = 136\)</span>, as shown in the plot below:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-3-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>This error is carried in the subsequent steps, and the full binary segmentation algorithm will output an additional change at <span class="math inline">\(\tau = 136\)</span>… Optimal Partitioning (OP), on the other hand, evaluates all possible segmentations considers the overall fit across the entire sequence. It is therefore less susceptible to adding “ghost” changepoints, as rather than focusing on the largest change at each step.</p>
<p>To illustrate, we compare the segmentations generated by both approaches:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-4-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
<section id="computational-complexity" class="level3" data-number="4.1.2">
<h3 data-number="4.1.2" class="anchored" data-anchor-id="computational-complexity"><span class="header-section-number">4.1.2</span> Computational Complexity</h3>
<p>Well, you may ask why not using OP all the time, then? Well, in changepoint detection, in which is the most appropiate method, we often have to keep track of the computational performance too, and Binary Segmentation is faster on average. For this reason, for large datasets where approximate solutions are acceptable, it might be the best option.</p>
<p>Specifically:</p>
<ul>
<li><p><strong>Binary Segmentation</strong> starts by dividing the entire sequence into two parts, iteratively applying changepoint detection to each segment. In the average case, it runs in <span class="math inline">\(\mathcal{O}(n \log n)\)</span> because it avoids searching every possible split point. However, in the worst case (if all data points are changepoints), the complexity can degrade to <span class="math inline">\(\mathcal{O}(n^2)\)</span>, as each step can require recalculating test statistics for a growing number of segments.</p></li>
<li><p><strong>Optimal Partitioning</strong>, on the other hand, solves the changepoint problem by recursively considering every possible split point up to time <span class="math inline">\(t\)</span>. The result is an optimal segmentation, but at the cost of <span class="math inline">\(\mathcal{O}(n^2)\)</span> computations. This holds true for both the average and worst cases, as it always requires a full exploration of all potential changepoints.</p></li>
</ul>
</section>
</section>
<section id="pelt-and-wbs" class="level2" data-number="4.2">
<h2 data-number="4.2" class="anchored" data-anchor-id="pelt-and-wbs"><span class="header-section-number">4.2</span> PELT and WBS</h2>
<p>Good news is, despite both algorithms have drawbacks, following <em>recent developments</em>, those have been solved. In the next sections, we will introduce two new algorithms, PELT and WBS.</p>
<section id="pelt-an-efficient-solution-to-op" class="level3" data-number="4.2.1">
<h3 data-number="4.2.1" class="anchored" data-anchor-id="pelt-an-efficient-solution-to-op"><span class="header-section-number">4.2.1</span> PELT: an efficient solution to OP</h3>
<p>In OP, we can reduce the numbers of checks to be performed at each iteration, reducing the complexity. This operation is called <em>pruning</em>. Specifically, on the condition that there exists a constant <span class="math inline">\(\kappa\)</span> such that for every <span class="math inline">\(l &lt; t &lt; u\)</span>:</p>
<p><span class="math display">\[
        \mathcal{L}(y_{l + 1:t}) + \mathcal{L}(y_{t + 1:u}) + \kappa \leq \mathcal{L}(y_{l + 1:u})
\]</span></p>
<p>It is possible to <em>prune</em> without resorting to an approximation. For many cost functions, such as the Gaussian cost, such a constant exists. Equating <span class="math inline">\(\kappa\)</span> to the penalty <span class="math inline">\(\beta\)</span>, gives us a computational trick to improve on the efficiency… The PELT algorithm – acronym for Pruned Exact Linear Time – (<span class="citation" data-cites="Killick">Killick, Fearnhead, and Eckley (<a href="references.html#ref-Killick" role="doc-biblioref">2012</a>)</span>) solves exactly the penalised minimization of <a href="3_multiple_changes.html#eq-optimal-partitioning" class="quarto-xref">Equation&nbsp;<span>3.4</span></a> with an expected computational cost that can be linear in <span class="math inline">\(n\)</span> – while still retaining <span class="math inline">\(\mathcal{O}(n^2)\)</span> computational complexity in the worst case. This is achieved by reducing the number of segment costs to evaluate at each iteration via an additional pruning step based on Condition <a href="3_multiple_changes.html#eq-optimal-partitioning" class="quarto-xref">Equation&nbsp;<span>3.4</span></a>. That is, if <span class="math display">\[\mathcal{Q}\tau + \mathcal{L}(y_{\tau + 1:t}) + \beta + \kappa \geq \mathcal{Q}_t \]</span> then we can safely prune the segment cost related to <span class="math inline">\(\tau\)</span>, as <span class="math inline">\(\tau\)</span> will never be the optimal changepoint location up to any time <span class="math inline">\(T &gt; t\)</span> in the future.</p>
<p>The intuition, is that, when <span class="math inline">\(\kappa = -\beta\)</span>, our penalty, then we would prune at every change detected. And if the changes increase linearly with the length of the data, this means that our algorithm will achieve a <span class="math inline">\(\mathcal{O}(n \log n)\)</span> computational complexity, without any drawbacks!</p>
<p><img src="source_imgs/OPPELT.png" class="img-fluid"></p>
<p>To reduce computational complexity, we can slightly modify the OP algorithm, to add the pruning condition above:</p>
<table class="table">
<tbody>
<tr class="odd">
<td style="text-align: left;">PELT</td>
</tr>
</tbody>
</table>
<div class="line-block"><strong>INPUT:</strong> Time series <span class="math inline">\(y = (y_1, ..., y_n)\)</span>, penalty <span class="math inline">\(\beta\)</span><br>
<strong>OUTPUT:</strong> Optimal changepoint vector <span class="math inline">\(cp_n\)</span><br>
<br>
Initialize <span class="math inline">\(\mathcal{Q}_0 \leftarrow -\beta\)</span><br>
Initialize <span class="math inline">\(cp_0 \leftarrow \{\}\)</span><br>
Initialise <span class="math inline">\(R_1 = \{0\}\)</span><br>
<br>
<strong>FOR</strong> <span class="math inline">\(t = 1, \dots, n\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(\mathcal{Q}_t \leftarrow \min_{\tau \in R_t} \left[ \mathcal{Q}_{\tau} + \mathcal{L}(y_{\tau + 1:t}) + \beta \right]\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(\hat\tau \leftarrow \text{arg}\min_{\tau \in R_t} \left[ \mathcal{Q}_{\tau} + \mathcal{L}(y_{\tau + 1:t}) + \beta \right]\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(cp_t \leftarrow (cp_{\hat\tau}, \hat\tau)\)</span> // Append the changepoint to the list at the last optimal point<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(R_{t+1} \leftarrow \{\tau \in \{R_t \cup \{t\}\} : \mathcal{Q}_\tau + \mathcal{L}(y_{\tau + 1:t})  \leq \mathcal{Q}_t \}\)</span> // prune the non-optimal changepoint locations<br>
<br>
<strong>RETURN</strong> <span class="math inline">\(cp_n\)</span></div>
<hr>
<p>As the segmentation retained is effectively the same, there are literally no disadvantages in using PELT over OP, if the cost function allows to do so.</p>
<p>However, PELT still has some disadvantages:</p>
<ul>
<li><p>PELT pruning works only over some cost functions, those for which the condition above is true. For example, in a special case of change-in-slope, as we will see in the workshop, we have that the cost from the next change depends on the location of the previous one, making it impossible for PELT to prune without loosing optimality.</p></li>
<li><p>We mentioned above how PELT over iterations at which a change is detected. For signals where changes are not frequent, PELT does not benefits from. A more sophisticated approach is that of <strong>FPOP</strong>, that prunes at every iteration. FPOP employs a different type of pruning, called functional pruning, that at every iteration only check costs that are likely associated to a change. However, despite the pruning is stronger FPOP works only over few selected models.</p></li>
</ul>
</section>
<section id="wbs-improving-on-binary-segmentation" class="level3" data-number="4.2.2">
<h3 data-number="4.2.2" class="anchored" data-anchor-id="wbs-improving-on-binary-segmentation"><span class="header-section-number">4.2.2</span> WBS: Improving on Binary Segmentation</h3>
<p>In BS, one of the issues that may arise, is an incorrect segmentation. WBS, <span class="citation" data-cites="Fryzlewicz:2014">Fryzlewicz (<a href="references.html#ref-Fryzlewicz:2014" role="doc-biblioref">2014</a>)</span>, is a multiple changepoints procedures that improve on the BS changepoint estimation via computing the initial segmentation cost of BS multiple times over <span class="math inline">\(M + 1\)</span> random subsets of the sequence, <span class="math inline">\(y_{s_1:t_1}, \dots, y_{s_M:t_M}, y_{1:n}\)</span>, picking the best subset according to what achieves the smallest segmentation cost and reiterating the procedure over that sample accordingly. The idea behind WBS lies in the fact that a favorable subset of the data <span class="math inline">\(y_{s_m:t_m}\)</span> could be drawn which contains a true change sufficiently separated from both sides <span class="math inline">\(s_m, t_m\)</span> of the sequence. By the inclusion of the <span class="math inline">\(y_{1:n}\)</span> entire sequence among the subsets, it is guaranteed that WBS will do no worse than the simple BS algorithm.</p>
<p>We can formally provide a description of WBS as a recursive procedure again, just adding a couple of alterations to the original Binary Segmentation:</p>
<hr>
<div class="line-block"><span class="math inline">\(\text{WBS}(y_{s:t}, \beta)\)</span><br>
</div>
<hr>
<div class="line-block"><strong>INPUT:</strong> Subseries <span class="math inline">\(y_{s:t} = \{y_s, \dots, y_t\}\)</span> of length <span class="math inline">\(t - s + 1\)</span>, penalty <span class="math inline">\(\beta\)</span><br>
<strong>OUTPUT:</strong> Set of detected changepoints <span class="math inline">\(cp\)</span><br>
<br>
<strong>IF</strong> <span class="math inline">\(t - s \leq 1\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<strong>RETURN</strong> <span class="math inline">\(\{\}\)</span> // No changepoint in segments of length 1 or less<br>
<br>
Draw <span class="math inline">\(\mathcal{M} = \{ [s_1, t_1], \dots, [s_M, t_M] \}\)</span> tuples of subset indexes;<br>
<span class="math inline">\(\mathcal{M} \leftarrow \mathcal{M} \cup \{[1, n]\}\)</span><br>
<strong>COMPUTE</strong><br>
<span class="math inline">\(\mathcal{Q} \leftarrow \underset{\substack{[s_m, t_m] \in \mathcal{M}\\ \tau \in \{s_m, \dots, t_m\}}}{\min} \left[ \mathcal{L}(y_{s:\tau}) + \mathcal{L}(y_{\tau+1:t}) - \mathcal{L}(y_{s:t}) + \beta \right]\)</span><br>
<br>
<strong>IF</strong> <span class="math inline">\(\mathcal{Q} &lt; 0\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(\hat{\tau} \leftarrow \underset{\substack{[s_m, t_m] \in \mathcal{M}\\ \tau \in \{s_m, \dots, t_m\}}}{\text{arg}\min} \left[ \mathcal{L}(y_{s:\tau}) + \mathcal{L}(y_{\tau+1:t}) - \mathcal{L}(y_{s:t}) \right]\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="math inline">\(cp \leftarrow \{ \hat{\tau}, \text{WBS}(y_{s:\hat{\tau}}, \beta), \text{WBS}(y_{\hat{\tau}+1:t}, \beta) + \hat\tau \}\)</span><br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<strong>RETURN</strong> <span class="math inline">\(cp\)</span><br>
<br>
<strong>RETURN</strong> <span class="math inline">\(\{\}\)</span> // No changepoint if <span class="math inline">\(-LR/2\)</span> is above penalty <span class="math inline">\(- \beta\)</span></div>
<hr>
<p>One of the major drawbacks of WBS is that in scenarios where we find frequent changepoints, in order to retain a close-to-optimal estimation, one should draw a higher number of <span class="math inline">\(M\)</span> intervals (usually of the order of thousands of intervals). This can be problematic given that WBS has computational complexity that grows linearly in the total length of the observations of the subsets.</p>
</section>
</section>
<section id="penalty-selection" class="level2" data-number="4.3">
<h2 data-number="4.3" class="anchored" data-anchor-id="penalty-selection"><span class="header-section-number">4.3</span> Penalty Selection</h2>
<p>In previous sections, we applied the changepoint detection algorithms using a penalty term of <span class="math inline">\(2 \log(n)\)</span>. As we’ll see, this is the <strong>BIC penalty</strong> (Bayes Information Criterion), a widely used penalty in changepoint detection. However, it is important to note that BIC is just one of several penalty types that can be applied…</p>
<p>As in the single change, some penalty may be more conservative then others! Choosing the correct penalty is key to obtaining a sensible segmentation of the data. The penalty term plays a significant role in balancing the goodness-of-fit of the model with its complexity:</p>
<ul>
<li>A lower penalty may lead to an over-segmentation, where too many changepoints are detected</li>
<li>A higher penalty could under-segment the data, missing important changepoints.</li>
</ul>
<p>The three most common penalties, are:</p>
<ul>
<li><p><strong>AIC (Akaike Information Criterion):</strong> The AIC penalty takes value of <span class="math inline">\(2p\)</span>, where <span class="math inline">\(p\)</span> is the number of parameters that one adds to the model. In multiple changes scenario, every new change, we add a new parameter to the model (as we estimate the signal). This, in OP and BS approaches, where the penalty is added at different iterations, shouls we fit a change, this translates in <span class="math inline">\(\beta = 2 \times 2 = 4\)</span> as our <span class="math inline">\(\beta\)</span>. While simple to apply, AIC is known to be <em>asymptotically inconsistent</em>: it tends to overestimate the number of changepoints as the sample size increases. Intuitively, this is because AIC is designed to minimize the prediction error rather than to identify the true model structure. It favors models that fit the data well, often leading to the inclusion of more changepoints than necessary.</p></li>
<li><p><strong>BIC (Bayesian Information Criterion):</strong> The BIC penalty is given by <span class="math inline">\(p \log(n)\)</span>. In our approaches, this translates to: <span class="math inline">\(\beta = 2 \log(n)\)</span>, that we add for each additional changepoint. BIC is generally more conservative than AIC and is consistent, meaning it will not overestimate the number of changepoints as the sample size grows.</p></li>
<li><p><strong>MBIC (Modified BIC):</strong> The MBIC penalty, from <span class="citation" data-cites="zhang2007modified">Zhang and Siegmund (<a href="references.html#ref-zhang2007modified" role="doc-biblioref">2007</a>)</span>, is an extension of the BIC that includes an extra term to account for the spacing of the changepoints. We can approximate it, in practice, by using a value of <span class="math inline">\(\beta = 3 \log(n)\)</span> as our penalty. In practice, it is even more conservative then the BIC penalty.</p></li>
</ul>
<section id="example-in-r-comparing-penalties-with-pelt" class="level3" data-number="4.3.1">
<h3 data-number="4.3.1" class="anchored" data-anchor-id="example-in-r-comparing-penalties-with-pelt"><span class="header-section-number">4.3.1</span> Example in R: Comparing Penalties with PELT</h3>
<p>Let’s now examine how different penalties impact the results of changepoint detection using the <code>changepoint</code> package in R. We’ll focus on the PELT method and compare the outcomes when using AIC, BIC, and MBIC penalties.</p>
<p>As a data sequence, we will pick a different chromosome in our Neuroblastoma dataset. Can you tell, by eye, how many changes are in this sequence?</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-5-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can compare the three penalties using the changepoint library, as below:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> one.dt<span class="sc">$</span>logratio</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>n <span class="ot">&lt;-</span> <span class="fu">length</span>(data)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Apply PELT with AIC, BIC, and MBIC penalties</span></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>cp_aic <span class="ot">&lt;-</span> <span class="fu">cpt.mean</span>(data, <span class="at">method =</span> <span class="st">"PELT"</span>, <span class="at">penalty =</span> <span class="st">"AIC"</span>)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>cp_bic <span class="ot">&lt;-</span> <span class="fu">cpt.mean</span>(data, <span class="at">method =</span> <span class="st">"PELT"</span>, <span class="at">penalty =</span> <span class="st">"BIC"</span>)</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>cp_mbic <span class="ot">&lt;-</span> <span class="fu">cpt.mean</span>(data, <span class="at">method =</span> <span class="st">"PELT"</span>, <span class="at">penalty =</span> <span class="st">"MBIC"</span>)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract changepoint locations for each penalty</span></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>cp_aic_points <span class="ot">&lt;-</span> <span class="fu">cpts</span>(cp_aic)</span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>cp_bic_points <span class="ot">&lt;-</span> <span class="fu">cpts</span>(cp_bic)</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>cp_mbic_points <span class="ot">&lt;-</span> <span class="fu">cpts</span>(cp_mbic)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a data frame for plotting with ggplot2</span></span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>plot_data <span class="ot">&lt;-</span> <span class="fu">data.frame</span>(</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>  <span class="at">index =</span> <span class="dv">1</span><span class="sc">:</span>n,</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>  <span class="at">data =</span> data)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Create data frames for changepoints with corresponding method labels</span></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>cp_df <span class="ot">&lt;-</span> <span class="fu">bind_rows</span>(</span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  <span class="fu">data.frame</span>(<span class="at">index =</span> cp_aic_points, <span class="at">method =</span> <span class="st">"AIC"</span>),</span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>  <span class="fu">data.frame</span>(<span class="at">index =</span> cp_bic_points, <span class="at">method =</span> <span class="st">"BIC"</span>),</span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>  <span class="fu">data.frame</span>(<span class="at">index =</span> cp_mbic_points, <span class="at">method =</span> <span class="st">"MBIC"</span>)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb1-25"><a href="#cb1-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-26"><a href="#cb1-26" aria-hidden="true" tabindex="-1"></a><span class="fu">ggplot</span>(plot_data, <span class="fu">aes</span>(<span class="at">x =</span> index, <span class="at">y =</span> data)) <span class="sc">+</span></span>
<span id="cb1-27"><a href="#cb1-27" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_point</span>() <span class="sc">+</span>  <span class="co"># Plot the data line first</span></span>
<span id="cb1-28"><a href="#cb1-28" aria-hidden="true" tabindex="-1"></a>  <span class="fu">geom_vline</span>(<span class="at">data =</span> cp_df, <span class="fu">aes</span>(<span class="at">xintercept =</span> index, <span class="at">color =</span> method)) <span class="sc">+</span></span>
<span id="cb1-29"><a href="#cb1-29" aria-hidden="true" tabindex="-1"></a>  <span class="fu">facet_grid</span>(method <span class="sc">~</span> .) <span class="sc">+</span></span>
<span id="cb1-30"><a href="#cb1-30" aria-hidden="true" tabindex="-1"></a>  <span class="fu">labs</span>(<span class="at">title =</span> <span class="st">"PELT with Different Penalties: AIC, BIC, MBIC"</span>, <span class="at">x =</span> <span class="st">"Index"</span>, <span class="at">y =</span> <span class="st">"Data"</span>) <span class="sc">+</span></span>
<span id="cb1-31"><a href="#cb1-31" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme_minimal</span>() <span class="sc">+</span></span>
<span id="cb1-32"><a href="#cb1-32" aria-hidden="true" tabindex="-1"></a>  <span class="fu">theme</span>(<span class="at">legend.position =</span> <span class="st">"none"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-6-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can see how from this example, the AIC likely overestimated the number of changepoints, while BIC and MBIC provided more conservative and reasonable segmentations. By eye, the MBIC seems to have done the better job!</p>
</section>
<section id="crops-running-with-multiple-penalties" class="level3" data-number="4.3.2">
<h3 data-number="4.3.2" class="anchored" data-anchor-id="crops-running-with-multiple-penalties"><span class="header-section-number">4.3.2</span> CROPS: running with multiple penalties</h3>
<p>Hopefully, the example above should have highlighted that finding the right penalty can be tricky. One solution, would be to run our algorithm for a range of penalties, and then choose a posteriori what the best segmentation is. The CROPS algorithm, from <span class="citation" data-cites="haynes2017computationally">Haynes, Eckley, and Fearnhead (<a href="references.html#ref-haynes2017computationally" role="doc-biblioref">2017</a>)</span>, is based on this idea. CROPS works alongside an existing penalised changepoint detection algorithm, like PELT or WBS: as long as the changepoint method can map a penalty value to a (decreasing) segmentation cost, CROPS could be applied.</p>
<p>CROPS takes as input a range of penalties <span class="math inline">\([\beta_{\text{min}}, \beta_{\text{max}}]\)</span>, and explores all possible segmentations within those two penalties in a clever way, to fit the changepoint model as least as we can. As CROPS calculates changepoints for a particular penalty, it keeps track of the range of penalty values where that specific set of changepoints is valid. This works because, for certain ranges of penalties, the set of changepoints stays the same.</p>
<p>E.g. for penalties between <span class="math inline">\(\beta_1\)</span> and <span class="math inline">\(\beta_2\)</span>, the changepoints might remain the same, so CROPS only needs to run the changepoint detection once for that range.</p>
<p>We won’t introduce the method formally, but in an intuitive way, CROPS works in this way:</p>
<ol type="1">
<li><p>It starts calculates changepoints at two extreme penalties: <span class="math inline">\(\beta_{\text{min}}\)</span> and <span class="math inline">\(\beta_{\text{max}}\)</span>. If those are the same, it quits.</p></li>
<li><p>Alternatively, as a binary search, CROPS selects a mid-point penalty <span class="math inline">\(\beta_\text{int}\)</span> based on whether the segmentation change, and runs the changepoint detection again on <span class="math inline">\([\beta_{\text{min}}, \beta_{\text{int}}]\)</span>, and <span class="math inline">\([\beta_{\text{int}}, \beta_{\text{max}}]\)</span>, refining its search for the next penalty.</p></li>
<li><p>It repeats 2 iteratively until no further segmentations are found.</p></li>
</ol>
<p>We can use CROPS to generate an <strong>elbow plot</strong> for selecting the appropriate penalty value in changepoint detection. In Data Science and Machine Learning, elbow plots are graphs that helps us choosing the appropiate value of a parameter, balancing between model complexity (in our case number of changepoints) and goodness of fit (how tightly our model fits the data).</p>
<p>In case of CROPS, we can plot the number of changepoints against the penalty value from our range. The curve typically shows a steep drop at first, as many changepoints are detected with low penalties, then flattens as the penalty increases and fewer changepoints are added. The <strong>elbow</strong> (hence its name) is the point where the rate of change in the number of changepoints significantly slows down:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-7-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>The elbow is a point of balance between model fit and complexity. As a rule of thumb, a good choices of a penalty reside in picking either the penalty that generates the segmentation at the elbow, or the one at the point immediately prior.</p>
<p>Going back to our neuroblastoma example above. We run CROPS for penalties <span class="math inline">\([2, 40]\)</span>, and we then generate the elbow plot:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">cpt.mean</span>(data, <span class="at">method =</span> <span class="st">"PELT"</span>, <span class="at">penalty  =</span> <span class="st">"CROPS"</span>, <span class="at">pen.value =</span> <span class="fu">c</span>(<span class="dv">2</span>, <span class="dv">40</span>))</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(out,<span class="at">diagnostic=</span><span class="cn">TRUE</span>)</span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v=</span><span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-8-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>We can see that the elbow is at 4 changepoints, therefore this could suggest that a segmentation with 4 changes might be the best!</p>
<p>This gives us:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="fu">cpts</span>(out, <span class="dv">3</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1]  3 17 52</code></pre>
</div>
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(out, <span class="at">ncpts=</span> <span class="dv">3</span>, <span class="at">type=</span><span class="st">"p"</span>, <span class="at">pch=</span><span class="dv">16</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-9-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="exercises" class="level2" data-number="4.4">
<h2 data-number="4.4" class="anchored" data-anchor-id="exercises"><span class="header-section-number">4.4</span> Exercises</h2>
<section id="workshop-4" class="level3" data-number="4.4.1">
<h3 data-number="4.4.1" class="anchored" data-anchor-id="workshop-4"><span class="header-section-number">4.4.1</span> Workshop 4</h3>
<ol type="1">
<li><p>Looking at last week workshop exercise solution, which points in the OP recursion would have been pruned by PELT? Check that the PELT pruning condition is true.</p></li>
<li><p>The model (not the cost!) for a single segment of a <em>continuous</em> change-in-slope is given by:</p></li>
</ol>
<p><span id="eq-continuous-slope"><span class="math display">\[
    y_t = \tau_i \theta_{\tau_i} + \theta_{\tau_{i+1}} (t - \tau_i) + \epsilon_t, \text{ for } t = \tau_i + 1, \dots, \tau_{i+1}, \epsilon_t \sim N(0, 1)
\tag{4.1}\]</span></span></p>
<p>where <span class="math inline">\(\theta_{\tau_i}\)</span> represents the value of the slope at changepoint <span class="math inline">\(\tau_i\)</span> and <span class="math inline">\(\phi_{\tau_{i+1}}\)</span> is the value at the next changepoint <span class="math inline">\(\tau_{i+1}\)</span>. Note, in this example, for simplicity, we assume the intercept is set equal to 0.</p>
<p>This model is a variation from the one we had next week as it enforces continuity, e.g.&nbsp;the value at the end of one segment, needs to be the at the next:</p>
<div class="cell">
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<ol type="a">
<li><p>Can you identify the elements where there is dependency across segments? Once you’ve done that, rewrite the model for one change by seting <span class="math inline">\(\tau_{i} = 0\)</span>. Would you be able to use PELT pruning with this one?</p></li>
<li><p>Write down the continuous model from equation <a href="#eq-continuous-slope" class="quarto-xref">Equation&nbsp;<span>4.1</span></a>, and the one from the previous point for a case where you have two segments, <span class="math inline">\(\theta_1, \theta_2\)</span>. Then have a look at the model from week 2! What are the differences across the three models?</p></li>
</ol>
<ol start="3" type="1">
<li>The PELT algorithm will only be able to deal with the discontinuous model. We will now revisit the Simpsons dataset, fitting this multiple changes model. This can be achieved via:</li>
</ol>
<div class="cell">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(changepoint)</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>data <span class="ot">&lt;-</span> <span class="fu">cbind</span>(y, <span class="dv">1</span>, <span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(y))</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>out <span class="ot">&lt;-</span> <span class="fu">cpt.reg</span>(data, <span class="at">method=</span><span class="st">"PELT"</span>)</span>
<span id="cb6-5"><a href="#cb6-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-6"><a href="#cb6-6" aria-hidden="true" tabindex="-1"></a><span class="fu">cat</span>(<span class="st">"Our changepoint estimates:"</span>, <span class="fu">cpts</span>(out))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Our changepoint estimates: 176 359 363 585 589 708</code></pre>
</div>
<div class="sourceCode cell-code" id="cb8"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="fu">plot</span>(out, <span class="at">ylab=</span><span class="st">"y"</span>, <span class="at">xlab=</span><span class="st">"t"</span>, <span class="at">pch=</span><span class="dv">16</span>)</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a><span class="fu">abline</span>(<span class="at">v =</span> <span class="fu">cpts</span>(out), <span class="at">col =</span> <span class="st">"red"</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="4_algos_and_penalties_files/figure-html/unnamed-chunk-12-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>Comment this segmentation. In which way we improved from the segmentation in week 2? What would you change?</p>
</section>
<section id="lab-4" class="level3" data-number="4.4.2">
<h3 data-number="4.4.2" class="anchored" data-anchor-id="lab-4"><span class="header-section-number">4.4.2</span> Lab 4</h3>
<p>In this lab we will test changepoint algorithms over some artificial data. Each sequence will have one of the following Gaussian change-in-mean patterns:<br>
<br>
<img src="source_imgs/scenarios.png" class="img-fluid"></p>
<p>The code below will generate 400 sequences, which will be stored in a list called <code>full_seqs</code>. Every 100 sequences you will have a different change-pattern, across the four different change patterns.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="fu">library</span>(tidyverse)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>generate_signal <span class="ot">&lt;-</span> <span class="cf">function</span>(n, <span class="at">pattern =</span> <span class="fu">c</span>(<span class="st">"none"</span>, <span class="st">"up"</span>, <span class="st">"updown"</span>, <span class="st">"rand1"</span>), <span class="at">nbSeg =</span> <span class="dv">8</span>, <span class="at">jumpSize =</span> <span class="dv">1</span>) {</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  type <span class="ot">&lt;-</span> <span class="fu">match.arg</span>(pattern)</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (type <span class="sc">==</span> <span class="st">"rand1"</span>) {</span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set.seed</span>(<span class="dv">42</span>)</span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a>    rand1CP <span class="ot">&lt;-</span> <span class="fu">rpois</span>(nbSeg, <span class="at">lambda =</span> <span class="dv">10</span>)</span>
<span id="cb9-9"><a href="#cb9-9" aria-hidden="true" tabindex="-1"></a>    r1 <span class="ot">&lt;-</span> <span class="fu">pmax</span>(<span class="fu">round</span>(rand1CP <span class="sc">*</span> n <span class="sc">/</span> <span class="fu">sum</span>(rand1CP)), <span class="dv">1</span>)</span>
<span id="cb9-10"><a href="#cb9-10" aria-hidden="true" tabindex="-1"></a>    s <span class="ot">&lt;-</span> <span class="fu">sum</span>(r1)</span>
<span id="cb9-11"><a href="#cb9-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-12"><a href="#cb9-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Adjust r1 to match sum to n</span></span>
<span id="cb9-13"><a href="#cb9-13" aria-hidden="true" tabindex="-1"></a>    r1 <span class="ot">&lt;-</span> <span class="cf">if</span> (s <span class="sc">&gt;</span> n) {</span>
<span id="cb9-14"><a href="#cb9-14" aria-hidden="true" tabindex="-1"></a>      <span class="cf">while</span> (<span class="fu">sum</span>(r1) <span class="sc">&gt;</span> n) r1[<span class="fu">which</span>(r1 <span class="sc">&gt;</span> <span class="dv">1</span>)[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">which</span>(r1 <span class="sc">&gt;</span> <span class="dv">1</span>)), <span class="dv">1</span>)]] <span class="ot">&lt;-</span> r1[<span class="fu">which</span>(r1 <span class="sc">&gt;</span> <span class="dv">1</span>)[<span class="fu">sample</span>(<span class="dv">1</span><span class="sc">:</span><span class="fu">length</span>(<span class="fu">which</span>(r1 <span class="sc">&gt;</span> <span class="dv">1</span>)), <span class="dv">1</span>)]] <span class="sc">-</span> <span class="dv">1</span></span>
<span id="cb9-15"><a href="#cb9-15" aria-hidden="true" tabindex="-1"></a>      r1</span>
<span id="cb9-16"><a href="#cb9-16" aria-hidden="true" tabindex="-1"></a>    } <span class="cf">else</span> {</span>
<span id="cb9-17"><a href="#cb9-17" aria-hidden="true" tabindex="-1"></a>      <span class="fu">sample</span>(<span class="fu">rep</span>(<span class="fu">seq_along</span>(r1), n <span class="sc">-</span> s)) <span class="sc">%&gt;%</span> <span class="fu">table</span>() <span class="sc">%&gt;%</span> <span class="fu">as.numeric</span>() <span class="sc">%&gt;%</span> <span class="st">`</span><span class="at">+</span><span class="st">`</span>(r1)</span>
<span id="cb9-18"><a href="#cb9-18" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb9-19"><a href="#cb9-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-20"><a href="#cb9-20" aria-hidden="true" tabindex="-1"></a>    <span class="fu">set.seed</span>(<span class="dv">43</span>)</span>
<span id="cb9-21"><a href="#cb9-21" aria-hidden="true" tabindex="-1"></a>    rand1Jump <span class="ot">&lt;-</span> <span class="fu">runif</span>(nbSeg, <span class="at">min =</span> <span class="fl">0.5</span>, <span class="at">max =</span> <span class="dv">1</span>) <span class="sc">*</span> <span class="fu">sample</span>(<span class="fu">c</span>(<span class="sc">-</span><span class="dv">1</span>, <span class="dv">1</span>), nbSeg, <span class="at">replace =</span> <span class="cn">TRUE</span>)</span>
<span id="cb9-22"><a href="#cb9-22" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb9-23"><a href="#cb9-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-24"><a href="#cb9-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Generate scenarios</span></span>
<span id="cb9-25"><a href="#cb9-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">switch</span>(</span>
<span id="cb9-26"><a href="#cb9-26" aria-hidden="true" tabindex="-1"></a>    type,</span>
<span id="cb9-27"><a href="#cb9-27" aria-hidden="true" tabindex="-1"></a>    <span class="at">none =</span> <span class="fu">rep</span>(<span class="dv">0</span>, n),</span>
<span id="cb9-28"><a href="#cb9-28" aria-hidden="true" tabindex="-1"></a>    <span class="at">up =</span> <span class="fu">rep</span>(<span class="fu">seq</span>(<span class="dv">0</span>, nbSeg <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">*</span> jumpSize, <span class="at">each =</span> n <span class="sc">/</span> nbSeg),</span>
<span id="cb9-29"><a href="#cb9-29" aria-hidden="true" tabindex="-1"></a>    <span class="at">updown =</span> <span class="fu">rep</span>((<span class="fu">seq</span>(<span class="dv">0</span>, nbSeg <span class="sc">-</span> <span class="dv">1</span>) <span class="sc">%%</span> <span class="dv">2</span>) <span class="sc">*</span> jumpSize, <span class="at">each =</span> n <span class="sc">/</span> nbSeg),</span>
<span id="cb9-30"><a href="#cb9-30" aria-hidden="true" tabindex="-1"></a>    <span class="at">rand1 =</span> <span class="fu">map2</span>(rand1Jump, r1, <span class="sc">~</span><span class="fu">rep</span>(.x <span class="sc">*</span> jumpSize, .y)) <span class="sc">%&gt;%</span> <span class="fu">unlist</span>()</span>
<span id="cb9-31"><a href="#cb9-31" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb9-32"><a href="#cb9-32" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-33"><a href="#cb9-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-34"><a href="#cb9-34" aria-hidden="true" tabindex="-1"></a>sims <span class="ot">&lt;-</span> <span class="fu">expand_grid</span>(<span class="at">pattern =</span> <span class="fu">c</span>(<span class="st">"none"</span>, <span class="st">"up"</span>, <span class="st">"updown"</span>, <span class="st">"rand1"</span>), <span class="at">rep =</span> <span class="dv">1</span><span class="sc">:</span><span class="dv">100</span>)</span>
<span id="cb9-35"><a href="#cb9-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-36"><a href="#cb9-36" aria-hidden="true" tabindex="-1"></a>full_seqs <span class="ot">&lt;-</span> <span class="fu">pmap</span>(sims, \(pattern, rep) {</span>
<span id="cb9-37"><a href="#cb9-37" aria-hidden="true" tabindex="-1"></a>  mu <span class="ot">&lt;-</span> <span class="fu">generate_signal</span>(<span class="fl">1e4</span>, pattern)</span>
<span id="cb9-38"><a href="#cb9-38" aria-hidden="true" tabindex="-1"></a>  <span class="fu">set.seed</span>(rep)</span>
<span id="cb9-39"><a href="#cb9-39" aria-hidden="true" tabindex="-1"></a>  y <span class="ot">&lt;-</span> mu <span class="sc">+</span> <span class="fu">rnorm</span>(<span class="fu">length</span>(mu))</span>
<span id="cb9-40"><a href="#cb9-40" aria-hidden="true" tabindex="-1"></a>  cps <span class="ot">&lt;-</span> <span class="fu">which</span>(<span class="fu">diff</span>(mu) <span class="sc">!=</span> <span class="dv">0</span>)</span>
<span id="cb9-41"><a href="#cb9-41" aria-hidden="true" tabindex="-1"></a><span class="fu">return</span>(<span class="fu">list</span>(<span class="at">y =</span> y, <span class="at">mu =</span> mu, <span class="at">cps =</span> cps, <span class="at">pattern =</span> pattern))</span>
<span id="cb9-42"><a href="#cb9-42" aria-hidden="true" tabindex="-1"></a>})</span>
<span id="cb9-43"><a href="#cb9-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-44"><a href="#cb9-44" aria-hidden="true" tabindex="-1"></a><span class="co"># each component of the list describes a sequence:</span></span>
<span id="cb9-45"><a href="#cb9-45" aria-hidden="true" tabindex="-1"></a><span class="fu">summary</span>(full_seqs[[<span class="dv">1</span>]])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>        Length Class  Mode     
y       10000  -none- numeric  
mu      10000  -none- numeric  
cps         0  -none- numeric  
pattern     1  -none- character</code></pre>
</div>
</div>
<ol type="1">
<li><p>Plot four sample sequences, each with a different change pattern, with superimposed signals. You should replicate the plot above.</p></li>
<li><p>Install the <code>changepoint</code> package. By researching <code>?cpt.mean</code>, learn about the change in mean function. Run the PELT algorithm for change in mean on the four sequences you picked above, with MBIC penalty.</p></li>
<li><p>Compare, in a simulation study, across the four different scenarios, performances of:</p>
<ol type="a">
<li><p>Binary Segmentation, with AIC and BIC penalty</p></li>
<li><p>PELT, with AIC and BIC penalty</p></li>
</ol></li>
</ol>
<p>You will need to compare performances in term of Mean Square Error of the fitted signal <span class="math inline">\(\text{MSE} = ||\mu_{1:n} - \hat\mu_{1:n}||^2_2\)</span>. A function has been already coded for you below:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>mse_loss <span class="ot">&lt;-</span> <span class="cf">function</span>(mu_true, mu_hat) {</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>  <span class="fu">return</span>(<span class="fu">sum</span>((mu_true <span class="sc">-</span> mu_hat) <span class="sc">^</span> <span class="dv">2</span>))</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Report results by scenario and algorithm.</p>
<p><strong>NOTE:</strong> You will be able to access parameters estimates via the function <code>param.est()</code>. To get <span class="math inline">\(\hat\mu_{1:n}\)</span>, necessary for the MSE computation above, we can use:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb12"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>results <span class="ot">&lt;-</span> <span class="co"># cpt.mean output here</span></span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a><span class="fu">rep</span>(<span class="fu">param.est</span>(result)<span class="sc">$</span>mean, <span class="at">times =</span> <span class="fu">diff</span>(<span class="fu">c</span>(<span class="dv">0</span>, cp_est, <span class="fu">length</span>(y))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>


<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list" style="display: none">
<div id="ref-Fryzlewicz:2014" class="csl-entry" role="listitem">
Fryzlewicz, Piotr. 2014. <span>“<span class="nocase">Wild binary segmentation for multiple change-point detection</span>.”</span> <em>Annals of Statistics</em> 42: 2243–81.
</div>
<div id="ref-haynes2017computationally" class="csl-entry" role="listitem">
Haynes, Kaylea, Idris A Eckley, and Paul Fearnhead. 2017. <span>“Computationally Efficient Changepoint Detection for a Range of Penalties.”</span> <em>Journal of Computational and Graphical Statistics</em> 26 (1): 134–43.
</div>
<div id="ref-Killick" class="csl-entry" role="listitem">
Killick, R., P. Fearnhead, and I. A. Eckley. 2012. <span>“Optimal Detection of Changepoints with a Linear Computational Cost.”</span> <em>Journal of the American Statistical Association</em> 107 (500): 1590–98.
</div>
<div id="ref-zhang2007modified" class="csl-entry" role="listitem">
Zhang, Nancy R, and David O Siegmund. 2007. <span>“A Modified Bayes Information Criterion with Applications to the Analysis of Comparative Genomic Hybridization Data.”</span> <em>Biometrics</em> 63 (1): 22–32.
</div>
</div>
</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button', {
    text: function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
  });
  clipboard.on('success', function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  });
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      return note.innerHTML;
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a href="./3_multiple_changes.html" class="pagination-link" aria-label="Multiple changepoints">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class="chapter-number">3</span>&nbsp; <span class="chapter-title">Multiple changepoints</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a href="./5_real_data.html" class="pagination-link" aria-label="Working with Real Data">
        <span class="nav-page-text"><span class="chapter-number">5</span>&nbsp; <span class="chapter-title">Working with Real Data</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->




</body></html>